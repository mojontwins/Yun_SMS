Const SCR_W = 16
Const SCR_H = 12

Const STATE_REP = 1
Const STATE_STRING = 2

Sub usage
	Print "$ unpackedmap.exe in.map out.h|bin=path w h tlock prefix [t0offs]"
	Print
	Print "If bin is specified as second parameter, output will be two separate files:"
	Print "map_prefix.bin and map_prefix_locks.bin in path"
End Sub

Function even (i As Integer) As Integer 
	Return ((i And 1) = 0)
End Function

Dim As Integer x, y, xx, yy, nPant, mapW, mapH, i, j, dat, f, mapsize, decosize, scrsize
Dim As Integer mapWtiles, mapPants, tLock, locksI, state, tileStrI, decoT, decoCt, XYct, t0
Dim As Integer counter
Dim As String o, prefix
Dim As uByte d, dp
'Redim As uByte m (0, 0)
'Redim As uByte decos (0, 0), decosI (0)
'Redim As uByte mOut (0, 0), mOutI (0)
Dim As uByte locks (63), tilestr (32)

' Sorry, but this is acting weird
Dim As uByte m (127, SCR_W * SCR_H - 1)
Dim As uByte decos (127, 127)
Dim As uByte decosXY (127, 127), XY (127)
Dim As uByte decosO (127, 127)
Dim As uByte decosI (127)
Dim As uByte decosOI (127)
Dim As uByte mOut (127, SCR_W * SCR_H - 1)
Dim As uByte mOutI (127)

If Command (6) = "" Then usage: End

If Command (7) <> "" Then t0 = Val (Command (7)) Else t0 = 0

Print "unpackedmap ... ";

mapW = Val (Command (3))
mapH = Val (Command (4))
mapWtiles = mapW * SCR_W
mapPants = mapW * mapH
tLock = Val (Command (5))
prefix = Command (6)

' Read map to big array
'Redim m (mapPants - 1, SCR_W * SCR_H - 1)
' Max 64 decos as per screen
'Redim decos (mapPants - 1, 127)
'Redim decosI (mapPants - 1)
'Redim mOut (mapPants - 1, SCR_W * SCR_H - 1)
'Redim mOutI (mapPants - 1)

' Reset indexes (not needed, but good practice).
For i = 0 To mapPants - 1
	decosI (i) = 0
	decosOI (i) = 0
	mOutI (i) = 0
Next i
locksI = 0

f = Freefile
Open Command (1) For Binary as #f
i = 0: dp = 0
While Not Eof (f)
	' Read from file
	Get #f, , d
	' Screen coordinates
	xx = (i \ SCR_W) Mod  mapW
	yy = i \ (SCR_W * SCR_H * mapW)
	' Tile coordinates
	x = i Mod SCR_W
	y = (i \ mapWtiles) Mod SCR_H
	' screen number
	nPant = xx + yy * mapW
	' Is d a lock' 
	If d = tLock Then
		locks (locksI) = nPant: locksI = locksI + 1
		locks (locksI) = x * 16 + y: locksI = locksI + 1
	End if
	' Write to big array
	m (nPant, x + y * SCR_W) = d - t0
	' Previous one
	dp = d
	' Counter
	i = i + 1
Wend
Close #f

' Write output
f = Freefile

If Instr (Command (2), "bin=") Then
	' Write map binary
	Open Right (Command (2), Len (Command (2)) - 4) & "\map_" & prefix & ".bin" For Binary As #f
	For nPant = 0 To mapPants - 1
		For i = 0 To SCR_W * SCR_H - 1
			d = m (nPant, i)
			Put #f, , d
		Next i
	Next nPant
	Close #f

	' Write locks binary
	If locksI Then
		Open Right (Command (2), Len (Command (2)) - 4) & "\map_" & prefix & "_locks.bin" For Binary As #f
		For i = 0 To locksI - 1
			d = locks (i)
			Put #f, , d
		Next i
	End If
	Close #f
Else
	Open Command (2) For Output As #f
	Print #f, "// unpacked(TM) map"
	Print #f, "// generated by unpackedmap.exe"
	Print #f, "// Copyleft 2016 The Mojon Twins"
	Print #f, ""
	Print #f, "// Map Size Is " & mapW & "x" & mapH
	Print #f, "// Screen Size Is " & SCR_W & "x" & SCR_H
	Print #f, ""
	Print #f, "#define N_BOLTS_" & Ucase (prefix) & " " & (locksI \ 2)
	Print #f, ""

	mapsize = 0

	' Write screens
	Print #f, "// Packed map, raw"
	Print #f, ""
	Print #f, "const unsigned char map_" & prefix & "_tiles [] = { "
	For nPant = 0 To mapPants - 1
		Print #f, "	";
		For i = 0 To SCR_W * SCR_H - 1
			d = m (nPant, i)
			Print #f, "0x" & Lcase (Hex (d, 2));
			mapsize = mapsize + 1
			If i < (SCR_W * SCR_H - 1) Or nPant < (mapPants - 1) Then Print #f, ", ";
		Next i
		Print #f, ""
	Next nPant
	Print #f, "};"

	Print #f, ""
	Print #f, "// Total map size in bytes is " & mapsize
	Print #f, ""

	' Write locks
	If locksI Then
		Print #f, "const unsigned char map_" & prefix & "_locks [] = {"
		Print #f, "	";
		For i = 0 To locksI - 1
			Print #f, "0x" & Lcase (Hex (locks (i), 2));
			If i < locksI - 1 Then Print #f, ", ";
		Next i
		Print #f, ""
		Print #f, "};"
		Print #f, ""
	End If

	' Exit cleanly
	Close #f
End If

Erase m, decos, decosI

Print " DONE!"
